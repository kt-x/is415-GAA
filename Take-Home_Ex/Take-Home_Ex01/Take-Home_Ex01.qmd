---
title: "Take-Home Exercise 1"
date: "30 Jan 2023"
date-modified: "`r Sys.Date()`"
number-sections: true
format: html
execute: 
  echo: true
  eval: true
  warning: false
editor: visual
---

# Overview

## Context

Water is an essential resource for people. The health of people depends on having access to clean water. It ensures peace and security, a clean environment, a sustainable economy, and a reduction in poverty. Yet more than 40% of the world's population lacks access to enough clean water. According to UN-Water, 1.8 billion people will be residing in nations or areas with a severe water shortage by 2025. Water scarcity is a serious threat to several sectors, including food security. Around 70% of the world's freshwater resources are used for agriculture.

## Objectives

Discover the geographical distribution of functional and non-function water points and their co-locations if any in Osun State, Nigeria.

## Data

| Type       | Name          | Format | Description                   | Source                        |
|---------------|---------------|---------------|---------------|---------------|
| Aspatial   | WPdx+         | csv    | Locations of water points     | WPdx Global Data Repositories |
| Geospatial | geoBoundaries | SHP    | geoBoundaries data of Nigeria | geoBoundaries                 |
| 1          | 1             | 1      | 1                             | 1                             |

: Table 1: Data used

# Importing and loading packages

For this exercise, we'll be using the following packages: 

-   sf: Manage and process vector-based geospatial data in R

-   spatstat: Perform 1st & 2nd spatial point patterns analysis + kernel density

-   raster: Reads, writes, manipulates, analyses, model of grid spatial data convert image output generate by spatstat into raster format 

-   maptools: Convert Spatial objects into ppp format of spatstat

-   tmap: plotting cartographic quality static point patterns maps or interactive maps by using leaflet API

-   tidyverse: 

```{r}
pacman::p_load(maptools, sf, raster, spatstat, tmap, tidyverse)
```

# Spatial Data Wrangling

## Data Geospatial

::: panel-tabset
#### Import NGA
```{r}
NGA <- st_read(dsn = "data/geospatial/", 
               layer = "nga_admbnda_adm2_osgof_20190417")%>%
  
st_transform(crs = 26392)
```

#### Glimpse NGA
```{r}
glimpse(NGA)
```
:::

## Aspatial
```{r}
wp_nga <- read_csv("data/aspatial/WPdx.csv") %>%
  filter(`#clean_country_name` == "Nigeria")
```

### Convert water point data into sf point features
```{r}
wp_nga$Geometry = st_as_sfc(wp_nga$`New Georeferenced Column`)
wp_nga
```

### convert this df into sf object
```{r}
wp_sf <- st_sf(wp_nga, crs=4326)
wp_sf
```

### Transforming into Nigeria projected coordinate system
```{r}
wp_sf <- wp_sf %>%
  st_transform(crs = 26392)
```


### Data Cleaning

#### Select specific fields 
```{r}
NGA <- NGA %>%
  select(c(3:4, 8:9))
```

#### Check for duplicates
```{r}
NGA$ADM2_EN[duplicated(NGA$ADM2_EN)==TRUE]
```
Replace values
```{r}
NGA$ADM2_EN[94] <- "Bassa, Kogi"
NGA$ADM2_EN[95] <- "Bassa, Plateau"
NGA$ADM2_EN[304] <- "Ifelodun, Kwara"
NGA$ADM2_EN[305] <- "Ifelodun, Osun"
NGA$ADM2_EN[355] <- "Irepodun, Kwara"
NGA$ADM2_EN[356] <- "Irepodun, Osun"
NGA$ADM2_EN[519] <- "Nasarawa, Kano"
NGA$ADM2_EN[520] <- "Nasarawa, Nasarawa"
NGA$ADM2_EN[546] <- "Obi, Benue"
NGA$ADM2_EN[547] <- "Obi, Nasarawa"
NGA$ADM2_EN[693] <- "Surulere, Lagos"
NGA$ADM2_EN[694] <- "Surulere, Oyo"
```


### EDA for Water Point Data
```{r}
#freq(data = wp_sf,
#     input = '#status_clean')
```










## Mapping the geospatial dataset
```{r}
tmap_mode('view')
tm_shape(NGA)+
  tm_dots()
```

```{r}
tmap_mode('plot')
```


# Geospatial Data wrangling

## Converting sf data frames to sp’s Spatial* class
::: panel-tabset
#### Code
```{r}
wp_sc <- as_Spatial(wp_sf)
NGA_sc <- as_Spatial(NGA)
```

#### wp_sc
```{r}
wp_sc
```
#### NGA_sc
```{r}
NGA_sc
```
:::



## Converting the Spatial* class into generic sp format
::: panel-tabset
#### Code
```{r}
wp_sp <- as(wp_sc, "SpatialPoints")
nga_sp <- as(NGA_sc, "SpatialPolygons")
```

#### wp_sp
```{r}
wp_sp
```
#### nga_sp
```{r}
nga_sp
```
:::

## Converting the generic sp format into spatstat’s ppp format
::: panel-tabset
#### Code
```{r}
wp_ppp <- as(wp_sp, "ppp")
wp_ppp
```

#### Plot
```{r}
plot(wp_ppp)
```

#### Summary 
```{r}
summary(wp_ppp)
```
:::

## Handling duplicates
```{r}
any(duplicated(wp_ppp))
```

```{r}
sum(multiplicity(wp_ppp) > 1)
```
The output shows that there are 0 duplicated point events.


Plot wp data
```{r}
#tmap_mode('view')
#tm_shape(wp_sc) +
#  tm_dots(alpha=0.4, 
#          size=0.05)
```


## Create owin object
owin object is designed to represent this polygonal region. We will be using to convert nigeria Spatial Polygon object into owin object of spatstat.
```{r}
nga_owin <- as(nga_sp, "owin")
```

```{r}
plot(nga_owin)
```

Summary
```{r}
summary(nga_owin)
```

### Combining point events object and owin object
```{r}
wpNGA_ppp = wp_ppp[nga_owin]
```


```{r}
summary(wpNGA_ppp)
```


# First-order Spatial Point Patterns Analysis

## Kernel Density Estimation


### Computing kernel density estimation using automatic bandwidth selection method
```{r}
kde_wpNGA_bw <- density(wpNGA_ppp,
                          sigma=bw.diggle,
                          edge=TRUE,
                          kernel="gaussian") 
```

```{r}
plot(kde_wpNGA_bw)
```

The density values of the output range from 0 to 0.000035 which is way too small to comprehend. This is because the default unit of measurement of svy21 is in meter. As a result, the density values computed is in “number of points per square meter”.

Before we move on to next section, it is good to know that you can retrieve the bandwidth used to compute the kde layer by using the code chunk below.

```{r}
bw <- bw.diggle(wpNGA_ppp)
bw
```

###  Rescalling KDE values
```{r}
wpNGA_ppp.km <- rescale(wpNGA_ppp, 1000, "km")
```

```{r}
kde_wpNGA.bw <- density(wpNGA_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_wpNGA.bw)
```


### Compare the output of using bw.diggle and bw.ppl methods
Baddeley et. (2016) suggested the use of the bw.ppl() algorithm because in ther experience it tends to produce the more appropriate values when the pattern consists predominantly of tight clusters. But they also insist that if the purpose of once study is to detect a single tight cluster in the midst of random noise then the bw.diggle() method seems to work best.
```{r}
kde_wpNGA.ppl <- density(wpNGA_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_wpNGA.bw, main = "bw.diggle")
plot(kde_wpNGA.ppl, main = "bw.ppl")
```


## Fixed and Adaptive KDE

### Computing KDE by using adaptive bandwidth
Fixed bandwidth method is very sensitive to highly skew distribution of spatial point patterns over geographical units for example urban versus rural. One way to overcome this problem is by using adaptive bandwidth instead.
```{r}
kde_wpNGA_adaptive <- adaptive.density(wpNGA_ppp.km, method="kernel")
plot(kde_wpNGA_adaptive)
```



