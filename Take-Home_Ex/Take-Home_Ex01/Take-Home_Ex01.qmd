---
title: "Take-Home Exercise 1"
date: "30 Jan 2023"
date-modified: "`r Sys.Date()`"
number-sections: true
format: html
execute: 
  echo: true
  eval: true
  warning: false
editor: visual
---

# Overview

## Context

Water is an essential resource for people. The health of people depends on having access to clean water. It ensures peace and security, a clean environment, a sustainable economy, and a reduction in poverty. Yet more than 40% of the world's population lacks access to enough clean water. According to UN-Water, 1.8 billion people will be residing in nations or areas with a severe water shortage by 2025. Water scarcity is a serious threat to several sectors, including food security. Around 70% of the world's freshwater resources are used for agriculture.

## Objectives

Discover the geographical distribution of functional and non-function water points and their co-locations if any in Osun State, Nigeria.

## Data

| Type       | Name          | Format | Description                   | Source                        |
|---------------|---------------|---------------|---------------|---------------|
| Aspatial   | WPdx+         | csv    | Locations of water points     | WPdx Global Data Repositories |
| Geospatial | geoBoundaries | SHP    | geoBoundaries data of Nigeria | geoBoundaries                 |
| 1          | 1             | 1      | 1                             | 1                             |

: Table 1: Data used

# Importing and loading packages

For this exercise, we'll be using the following packages: 


\| Name \| Description \| \|------\|-------------\| \| sf \| Manage and process vector-based geospatial data in R. \| \| spatstat \| Perform 1st & 2nd spatial point patterns analysis + kernel density \| \| raster \| Reads, writes, manipulates, analyses, model of grid spatial data convert image output generate by spatstat into raster format \| \| maptools \| convert Spatial objects into ppp format of spatstat \| \| tmap \| plotting cartographic quality static point patterns maps or interactive maps by using leaflet API \| \| 1 \| 1 \|

: Table 2: Packages used

-   sf: Manage and process vector-based geospatial data in R.

-   spatstat: Perform 1st & 2nd spatial point patterns analysis + kernel density

-   raster which reads, writes, manipulates, analyses, model of gridded spatial data and convert image output generate by spatstat into raster format.

-   maptools which provides a set of tools for manipulating geographic data and converting Spatial objects into ppp format of spatstat.

-   tmap which provides functions for plotting cartographic quality static point patterns maps or interactive maps by using leaflet API.

-   tidyverse

```{r}
pacman::p_load(maptools, sf, raster, spatstat, tmap, tidyverse)
```

# Spatial Data Wrangling

## Data Geospatial
```{r}
NGA <- st_read(dsn = "data/geospatial/", 
               layer = "nga_admbnda_adm2_osgof_20190417")%>%
  
st_transform(crs = 26392)
```


## Aspatial
```{r}
wp_nga <- read_csv("data/aspatial/WPdx.csv") %>%
  filter(`#clean_country_name` == "Nigeria")
```

### Convert water point data into sf point features
```{r}
wp_nga$Geometry = st_as_sfc(wp_nga$`New Georeferenced Column`)
wp_nga
```

### convert this df into sf object
```{r}
wp_sf <- st_sf(wp_nga, crs=4326)
wp_sf
```

### Transforming into Nigeria projected coordinate system
```{r}
wp_sf <- wp_sf %>%
  st_transform(crs = 26392)
```


### Data Cleaning

#### Select specific fields 
```{r}
NGA <- NGA %>%
  select(c(3:4, 8:9))
```

#### Check for duplicates
```{r}
NGA$ADM2_EN[duplicated(NGA$ADM2_EN)==TRUE]
```
Replace values
```{r}
NGA$ADM2_EN[94] <- "Bassa, Kogi"
NGA$ADM2_EN[95] <- "Bassa, Plateau"
NGA$ADM2_EN[304] <- "Ifelodun, Kwara"
NGA$ADM2_EN[305] <- "Ifelodun, Osun"
NGA$ADM2_EN[355] <- "Irepodun, Kwara"
NGA$ADM2_EN[356] <- "Irepodun, Osun"
NGA$ADM2_EN[519] <- "Nasarawa, Kano"
NGA$ADM2_EN[520] <- "Nasarawa, Nasarawa"
NGA$ADM2_EN[546] <- "Obi, Benue"
NGA$ADM2_EN[547] <- "Obi, Nasarawa"
NGA$ADM2_EN[693] <- "Surulere, Lagos"
NGA$ADM2_EN[694] <- "Surulere, Oyo"
```


# EDA for Water Point Data
```{r}
#freq(data = wp_sf,
#     input = '#status_clean')
```



## Mapping the geospatial dataset
```{r}
tmap_mode('view')
tm_shape(NGA)+
  tm_dots()
```

```{r}
tmap_mode('plot')
```


# Geospatial Data wrangling

## Converting sf data frames to sp’s Spatial* class
```{r}
wp_sc <- as_Spatial(wp_sf)
NGA_sc <- as_Spatial(NGA)
```

View the details
```{r}
wp_sc
```

```{r}
NGA_sc
```

## Converting the Spatial* class into generic sp format

```{r}
wp_sp <- as(wp_sc, "SpatialPoints")
nga_sp <- as(NGA_sc, "SpatialPolygons")
```


```{r}
wp_sp
```

```{r}
nga_sp
```


## Converting the generic sp format into spatstat’s ppp format
```{r}
wp_ppp <- as(wp_sp, "ppp")
wp_ppp
```

Plot and examine the difference
```{r}
plot(wp_ppp)
```

Summary 
```{r}
summary(wp_ppp)
```


## Handling duplicates
```{r}
any(duplicated(wp_ppp))
```
```{r}
multiplicity(wp_ppp)
```


```{r}
sum(multiplicity(wp_ppp) > 1)
```
The output shows that there are 0 duplicated point events.


Plot wp data
```{r}
#tmap_mode('view')
#tm_shape(wp_sc) +
#  tm_dots(alpha=0.4, 
#          size=0.05)
```


## Create owin object
owin object is designed to represent this polygonal region. We will be using to convert nigeria Spatial Polygon object into owin object of spatstat.
```{r}
nga_owin <- as(nga_sp, "owin")
```

```{r}
plot(nga_owin)
```

Summary
```{r}
summary(nga_owin)
```

### Combining point events object and owin object
```{r}
wpNGA_ppp = wp_ppp[nga_owin]
```


```{r}
summary(wpNGA_ppp)
```


# First-order Spatial Point Patterns Analysis

## Kernel Density Estimation


### Computing kernel density estimation using automatic bandwidth selection method
```{r}
kde_wpNGA_bw <- density(wpNGA_ppp,
                          sigma=bw.diggle,
                          edge=TRUE,
                          kernel="gaussian") 
```

```{r}
plot(kde_wpNGA_bw)
```

The density values of the output range from 0 to 0.000035 which is way too small to comprehend. This is because the default unit of measurement of svy21 is in meter. As a result, the density values computed is in “number of points per square meter”.

Before we move on to next section, it is good to know that you can retrieve the bandwidth used to compute the kde layer by using the code chunk below.

```{r}
bw <- bw.diggle(wpNGA_ppp)
bw
```

###  Rescalling KDE values
```{r}
wpNGA_ppp.km <- rescale(wpNGA_ppp, 1000, "km")
```

```{r}
kde_wpNGA.bw <- density(wpNGA_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_wpNGA.bw)
```








